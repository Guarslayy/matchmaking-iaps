# Архитектура проекта

Этот документ описывает архитектуру прототипа системы матчмейкинга, реализуемой в рамках предмета **IAPS21.1**. Архитектура разделена на несколько слоёв, что упрощает разработку и позволяет разным членам команды работать параллельно.

## Общий обзор

Система моделирует очередь игроков и работу различных алгоритмов подбора. Пользователь выбирает алгоритм, система находит соперника, случайно определяет исход матча, обновляет рейтинг ELO и сохраняет результат. UI отражает состояние игрока, показывает историю и предоставляет кнопку для поиска следующего матча.

С точки зрения **software engineering**, проект разделён на следующие подсистемы:

1. **Domain** — чистые модели и бизнес‑правила.
2. **Application services** — операции, связывающие домен с инфраструктурой.
3. **Infrastructure** — конкретные реализации хранилищ, адаптеры БД, http‑сервер.
4. **Presentation (UI)** — фронтенд, который взаимодействует с backend через REST API.

## Слои

### 1. Domain

В слое домена определяются основные понятия и правила системы. Домен не зависит от деталей реализации (HTTP, SQLite). Здесь находятся:

- **Player** — игрок с полями `id`, `name`, `elo`, `gamesPlayed`, `lastOpponents`, `colorHistory`.
- **Match** — матч между двумя игроками: `id`, `playerId`, `opponentId`, `result` (win/lose), `eloBefore`, `eloAfter`, `opponentElo`, `color`, `algorithmUsed`, `createdAt`.
- **QueueRequest** — заявка на матч: `id`, `playerId`, `createdAt`, `timeControl`.
- **Elo** — модуль, реализующий формулу расчёта нового рейтинга ELO на основе текущего рейтинга игроков и результата.
- **Score** — функция оценки качества пары игроков. Учёт разницы рейтингов, времени ожидания, баланса цвета и того, играли ли эти игроки недавно.
- **MatchmakingAlgorithm** — интерфейс для алгоритмов подбора: определяет метод `findPair(queue: QueueRequest[]): Match | null`.
- **Baseline**, **Greedy**, **BatchLite** — реализации `MatchmakingAlgorithm`.

### 2. Services (Application)

Слой сервисов связывает домен и инфраструктуру. Здесь реализуются use cases:

- **registerPlayer(name)** — создание игрока, присвоение начального рейтинга.
- **findMatch(playerId, algorithmType)** — добавление игрока в очередь и поиск соперника выбранным алгоритмом.
- **completeMatch(match, result)** — финализация матча: случайное определение победителя, обновление ELO, сохранение матча и статистики.
- **getProfile(playerId)** — получение информации о профиле (ELO, количество игр).
- **getHistory(playerId)** — получение списка матчей игрока.
- **getMetrics(algorithmType)** — расчёт усреднённых метрик: среднее время ожидания, средняя разница рейтингов, время работы алгоритма.

### 3. Infrastructure

Слой инфраструктуры содержит реализации хранилищ и адаптеров для работы со сторонними системами:

- **PlayerRepository** — работа с таблицей `players` (SQLite). Методы: `save(Player)`, `findById(id)`, `update(Player)`.
- **MatchRepository** — работа с таблицей `matches`.
- **QueueRepository** — очередь заявок. Реализована либо через таблицу `queue_requests`, либо как in‑memory структура, если это достаточно для целей симуляции.
- **Database** — подключение к SQLite, миграции.
- **HTTP server** — Express (Node.js). Реализует REST API и преобразует входящие запросы в вызовы сервисов.

### 4. Presentation (UI)

Фронтенд написан на React (Typescript) и взаимодействует с backend через HTTP. UI состоит из нескольких страниц и компонентов:

- **StartPage** — стартовая страница с кнопкой «Find Match» и выбором алгоритма.
- **ProfilePage** — отображает имя, ELO, общее количество матчей. Загружает данные через endpoint `/players/:id`.
- **HistoryPage** — показывает историю матчей: соперник, цвет, изменение рейтинга. Загружает данные через `/players/:id/history`.
- **MatchResultModal** — модальное окно, которое показывается после завершения матча. Содержит текст «Победа!» или «Поражение!», изменение ELO и кнопку закрытия.
- **Navbar** — навигационное меню между страницами.
  Состояние текущего пользователя (playerId) хранится в localStorage и/или в React context/store.

## База данных

Используется легковесная **SQLite**. Схема БД минимальна:

- **players**: `id` (integer, primary key), `name` (text), `elo` (integer), `gamesPlayed` (integer), `createdAt` (datetime).
- **matches**: `id` (integer, primary key), `playerId` (integer), `opponentId` (integer), `result` (text), `eloBefore` (integer), `eloAfter` (integer), `opponentElo` (integer), `color` (text), `algorithmUsed` (text), `createdAt` (datetime).
- **queue_requests**: `id` (integer, primary key), `playerId` (integer), `createdAt` (datetime), `timeControl` (text).

Для тестирования можно сгенерировать N рандомных игроков при старте приложения.

## Взаимодействия

Ниже приведены упрощённые последовательности действий.

### Регистрация игрока

1. UI отправляет POST `/players` с полем `name`.
2. Backend вызывает сервис `registerPlayer`, который создаёт `Player` с базовым ELO (например 1200), сохраняет в `PlayerRepository` и возвращает DTO.
3. UI сохраняет `playerId` и перенаправляет на страницу профиля.

### Поиск матча

1. UI отправляет POST `/match/find` с `playerId` и выбранным `algorithmType` (baseline, greedy, batch).
2. Backend добавляет заявку в очередь (`QueueRepository`).
3. Запускается выбранный алгоритм, который анализирует очередь и находит оптимальную пару. Если пара найдена, создаётся объект `Match`.
4. Сервис `completeMatch` случайно определяет победителя (50/50), пересчитывает ELO обоих игроков через `Elo`, сохраняет `Match` в репозиторий.
5. Endpoint возвращает результат матча (соперник, новое значение ELO, исход).
6. UI показывает `MatchResultModal`, затем обновляет профиль и историю.

### Получение истории и метрик

1. UI отправляет GET `/players/:id/history` → возвращается массив матчей.
2. UI отправляет GET `/metrics?algorithm=greedy` → возвращаются усреднённые показатели качества для указанного алгоритма.

## Распределение по команде

- **Тимлид / Backend Dev**: организует репозиторий, описывает архитектуру, пишет core домен, сервисы и базовые алгоритмы, настраивает базу.
- **Backend Dev**: реализует все репозитории, алгоритмы подбора, REST endpoints, метрики.
- **Frontend Dev**: создаёт React приложение, верстает UI, интегрирует API.
- **Дизайнер**: подготавливает макеты и общую визуальную стилистику (цвета, шрифты, расположение элементов). В проекте предлагается минимальный дизайн, ориентированный на функциональность.

## Заключение

Эта архитектура проста, но разделение на слои помогает поддерживать код чистым и понятным. Реальные алгоритмы матчмейкинга могут быть гораздо сложнее, но для учебной симуляции достаточно baseline, greedy и batch lite реализаций. Основная цель — продемонстрировать подход к проектированию, разбиению задач и коллективной работе над небольшим проектом.
